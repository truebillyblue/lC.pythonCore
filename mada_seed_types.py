from __future__ import annotations

import uuid
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

try:
    from pydantic import BaseModel, Field, model_validator, ConfigDict # RootModel not used, validator replaced
    PYDANTIC_AVAILABLE = True
except ImportError:
    PYDANTIC_AVAILABLE = False
    # Fallback to dataclasses if Pydantic is not available
    from dataclasses import dataclass, field as dc_field

# --- Base Models (if using Pydantic) ---
if PYDANTIC_AVAILABLE:
    class MadaBaseModel(BaseModel):
        model_config = ConfigDict(
            arbitrary_types_allowed=True,
            validate_assignment=True # Assuming this is desired; can be omitted if not.
        )

    # For fields that can be one of several types
    # Example: content: Union[str, Dict[str, Any]]
else:
    # Dataclass version of MadaBaseModel (conceptual)
    # Actual implementation will be per-class
    pass

# --- L1: Startle Layer ---

# L1_startle_context.signal_components_metadata_L1 item
if PYDANTIC_AVAILABLE:
    class SignalComponentMetadataL1(MadaBaseModel):
        component_role_L1: str = Field(..., description="Role of this component within the input event as identified by L1 (e.g., 'primary_text_content', 'attachment_file', 'metadata_header', 'embedded_image_data').")
        raw_signal_ref_uid_L1: str = Field(..., description="CRUX UID generated by L1 referencing the content of this specific signal component.")
        byte_size_hint_L1: Optional[int] = Field(None, description="Approximate size of this component in bytes, if determinable by L1 from input headers or initial read.")
        encoding_status_L1: Literal["AssumedUTF8_TextHint", "DetectedBinary", "PossibleEncodingIssue_L1", "Unknown_L1"] = Field(..., description="Basic encoding check status for this component as determined by L1.")
        media_type_hint_L1: Optional[str] = Field(None, description="Media type hint (e.g., MIME type from input source) for this component, if available to L1.")
        # No error_details here as per schema for this sub-object
else:
    @dataclass
    class SignalComponentMetadataL1:
        component_role_L1: str
        raw_signal_ref_uid_L1: str
        encoding_status_L1: str # Literal replacement
        byte_size_hint_L1: Optional[int] = None
        media_type_hint_L1: Optional[str] = None

# L1_startle_context (L1_startle_context_obj in SOP)
if PYDANTIC_AVAILABLE:
    class L1StartleContext(MadaBaseModel):
        version: str = Field("0.1.1", pattern=r"^\d+\.\d+\.\d+$", description="Version of this L1_startle_context schema.")
        L1_epistemic_state_of_startle: Literal["Startle_Complete_SignalRefs_Generated", "LCL-Failure-Internal_L1", "LCL-Failure-UID_Generation_L1"] = Field(..., description="Final epistemic state of L1 startle processing.")
        trace_creation_time_L1: datetime = Field(..., description="The precise ISO8601 UTC timestamp when the signal reception triggered the L1 startle event.")
        input_origin_L1: Optional[str] = Field(None, description="Identifier or description of the input source/channel for the overall event.")
        signal_components_metadata_L1: List[SignalComponentMetadataL1] = Field(..., min_length=1, description="An array describing each distinct data component received.")
        error_details: Optional[str] = Field(None, description="Details of any error that occurred during L1 processing.")
else:
    @dataclass
    class L1StartleContext:
        L1_epistemic_state_of_startle: str # Literal replacement
        trace_creation_time_L1: datetime
        signal_components_metadata_L1: List[SignalComponentMetadataL1]
        version: str = "0.1.1"
        input_origin_L1: Optional[str] = None
        error_details: Optional[str] = None

# L1_trace
if PYDANTIC_AVAILABLE:
    class L1Trace(MadaBaseModel):
        version_L1_trace_schema: str = Field("0.1.0", pattern=r"^\d+\.\d+\.\d+$")
        sop_name: Literal["lC.SOP.startle"] = "lC.SOP.startle"
        completion_timestamp_L1: datetime
        epistemic_state_L1: Literal["Startle_Complete_SignalRefs_Generated", "LCL-Failure-Internal_L1", "LCL-Failure-UID_Generation_L1"]
        L1_trace_creation_time_from_context: datetime
        L1_input_origin_from_context: Optional[str] = None
        L1_signal_component_count: int = Field(..., ge=1) # Greater than or equal to 1
        L1_generated_trace_id: Optional[str] = None # CRUX UID
        L1_generated_raw_signal_ref_uids_summary: Optional[Dict[str, Any]] = None # Simplified for now
        L1_applied_policy_refs: List[str] = dc_field(default_factory=list) if not PYDANTIC_AVAILABLE else Field(default_factory=list)
        error_details: Optional[str] = None
else:
    @dataclass
    class L1Trace:
        completion_timestamp_L1: datetime
        epistemic_state_L1: str # Literal replacement
        L1_trace_creation_time_from_context: datetime
        L1_signal_component_count: int
        version_L1_trace_schema: str = "0.1.0"
        sop_name: str = "lC.SOP.startle" # Literal replacement
        L1_input_origin_from_context: Optional[str] = None
        L1_generated_trace_id: Optional[str] = None
        L1_generated_raw_signal_ref_uids_summary: Optional[Dict[str, Any]] = None
        L1_applied_policy_refs: List[str] = dc_field(default_factory=list)
        error_details: Optional[str] = None


# --- Placeholder Models for L2-L7 (Content and Trace Objects) ---
# These will be simple placeholders for now.
if PYDANTIC_AVAILABLE:
    class PlaceholderContentObj(MadaBaseModel):
        version: str = Field("0.0.0-placeholder")
        description: str = "Placeholder for future layer object."
        error_details: Optional[str] = None # Adding error_details for consistency

    class PlaceholderTraceObj(MadaBaseModel):
        version_Lx_trace_schema: str = Field("0.0.0-placeholder")
        sop_name: str = "PlaceholderSOP"
        completion_timestamp_Lx: Optional[datetime] = None
        epistemic_state_Lx: str = "Pending_Lx"
        error_details: Optional[str] = None # Adding error_details for consistency
else:
    @dataclass
    class PlaceholderContentObj:
        version: str = "0.0.0-placeholder"
        description: str = "Placeholder for future layer object."
        error_details: Optional[str] = None

    @dataclass
    class PlaceholderTraceObj:
        version_Lx_trace_schema: str = "0.0.0-placeholder"
        sop_name: str = "PlaceholderSOP"
        completion_timestamp_Lx: Optional[datetime] = None
        epistemic_state_Lx: str = "Pending_Lx"
        error_details: Optional[str] = None

# --- L2-L7 Structures (using placeholders) ---

# L2 Frame Type

# Enum for L2 Epistemic State of Framing
class L2EpistemicStateOfFramingEnum(str, Enum):
    FRAMED = "Framed"
    LCL_CLARIFY_STRUCTURE = "LCL-Clarify-Structure"
    LCL_DEFER_STRUCTURE = "LCL-Defer-Structure"
    LCL_FAILURE_SIZE_NOISE = "LCL-Failure-SizeNoise"
    LCL_FAILURE_AMBIGUOUS_FRAME = "LCL-Failure-AmbiguousFrame"
    LCL_FAILURE_MISSING_COMMS_CONTEXT = "LCL-Failure-MissingCommsContext"
    LCL_FAILURE_INTERNAL_L2 = "LCL-Failure-Internal_L2"

# Enum for L2 Temporal Hint Provenance
class TemporalHintProvenanceL2Enum(str, Enum):
    EXPLICIT_CONTENT_L2_PARSED = "explicit_content_L2_parsed"
    EXPLICIT_METADATA_L2_USED = "explicit_metadata_L2_used"
    FALLBACK_L1_CREATION_TIME = "fallback_L1_creation_time"
    PARSING_ERROR_L2 = "parsing_error_L2"

# Enum for L2 Input Class
class InputClassL2Enum(str, Enum):
    PROMPT = "prompt"
    COMMS = "comms"
    MIXED = "mixed"
    UNKNOWN_L2_CLASSIFIED = "unknown_L2_classified"

# Enum for L2 Validation Status of Frame
class L2ValidationStatusOfFrameEnum(str, Enum):
    SUCCESS_FRAMED = "Success_Framed"
    FAILURE_SIZEORNOISE = "Failure_SizeOrNoise" # Note: Schema has "SizeOrNoise"
    FAILURE_NOSTRUCTUREDETECTED = "Failure_NoStructureDetected"
    FAILURE_AMBIGUOUSSTRUCTURE = "Failure_AmbiguousStructure"
    FAILURE_MISSINGCOMMSCONTEXT = "Failure_MissingCommsContext"
    # Adding FAILURE_INTERNALERROR as it's commonly used in SOP logic for L2, even if not in this specific schema path for L2_validation_status_of_frame
    FAILURE_INTERNALERROR = "Failure_InternalError" 


if PYDANTIC_AVAILABLE:
    # Model for L2 Temporal Hint
    class TemporalHintL2(MadaBaseModel):
        value: datetime
        provenance: TemporalHintProvenanceL2Enum

    # Model for L2 Communication Context
    class CommunicationContextL2(MadaBaseModel):
        source_agent_uid_L2: Optional[str] = None
        destination_agent_uid_L2: Optional[str] = None
        origin_environment_L2: Optional[str] = None
        interaction_channel_L2: Optional[str] = None

    class L2FrameTypeObj(PlaceholderContentObj): # Inherits version, description, error_details
        # L2 specific fields can be added later if needed for shell
        input_class_L2: Optional[InputClassL2Enum] = None # Use Enum
        frame_type_L2: Optional[str] = None  # Example from schema
        temporal_hint_L2: Optional[TemporalHintL2] = None # Use the new TemporalHintL2 model
        communication_context_L2: Optional[CommunicationContextL2] = None # Use the new CommunicationContextL2 model
        L2_validation_status_of_frame: Optional[L2ValidationStatusOfFrameEnum] = None # Use Enum
        L2_epistemic_state_of_framing: Optional[L2EpistemicStateOfFramingEnum] = None # Use the Enum
        L2_anomaly_flags_from_framing: Optional[List[str]] = Field(default_factory=list)
        L2_framing_confidence_score: Optional[float] = None # As per schema: number, nullable
    class L2Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.frame_click"
else:
    # Dataclass for L2 Temporal Hint Provenance Enum (conceptually, used as str)
    # No direct Enum for dataclass str fields, but values should match
    
    @dataclass
    class TemporalHintL2:
        value: datetime
        provenance: str # Store as string, should be one of TemporalHintProvenanceL2Enum values

    @dataclass
    class CommunicationContextL2:
        source_agent_uid_L2: Optional[str] = None
        destination_agent_uid_L2: Optional[str] = None
        origin_environment_L2: Optional[str] = None
        interaction_channel_L2: Optional[str] = None

    @dataclass
    class L2FrameTypeObj(PlaceholderContentObj):
        input_class_L2: Optional[InputClassL2Enum] = None # Use Enum conceptually; will be string for dataclass if not using advanced libraries
        frame_type_L2: Optional[str] = None
        temporal_hint_L2: Optional[TemporalHintL2] = None # Use the new TemporalHintL2 dataclass
        communication_context_L2: Optional[CommunicationContextL2] = None # Use the new CommunicationContextL2 dataclass
        L2_validation_status_of_frame: Optional[L2ValidationStatusOfFrameEnum] = None # Use Enum conceptually
        L2_epistemic_state_of_framing: Optional[L2EpistemicStateOfFramingEnum] = None # Use the Enum
        L2_anomaly_flags_from_framing: Optional[List[str]] = dc_field(default_factory=list)
        L2_framing_confidence_score: Optional[float] = None # As per schema: number, nullable
    @dataclass
    class L2Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.frame_click"


# L3 Surface Keymap
if PYDANTIC_AVAILABLE:
    class L3SurfaceKeymapObj(PlaceholderContentObj): pass # Placeholder
    class L3Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.keymap_click"
else:
    @dataclass
    class L3SurfaceKeymapObj(PlaceholderContentObj): pass
    @dataclass
    class L3Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.keymap_click"

# L4 Anchor State
if PYDANTIC_AVAILABLE:
    class L4AnchorStateObj(PlaceholderContentObj): pass # Placeholder
    class L4Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.anchor_click"
else:
    @dataclass
    class L4AnchorStateObj(PlaceholderContentObj): pass
    @dataclass
    class L4Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.anchor_click"

# L5 Field State
if PYDANTIC_AVAILABLE:
    class L5FieldStateObj(PlaceholderContentObj): pass # Placeholder
    class L5Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.field_click"
else:
    @dataclass
    class L5FieldStateObj(PlaceholderContentObj): pass
    @dataclass
    class L5Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.field_click"

# L6 Reflection Payload
if PYDANTIC_AVAILABLE:
    class L6ReflectionPayloadObj(PlaceholderContentObj): pass # Placeholder
    class L6Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.reflect_boom"
else:
    @dataclass
    class L6ReflectionPayloadObj(PlaceholderContentObj): pass
    @dataclass
    class L6Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.reflect_boom"

# L7 Encoded Application
if PYDANTIC_AVAILABLE:
    class L7EncodedApplication(PlaceholderContentObj): pass # Placeholder, actual version is "0.1.1" as per last task
    class L7Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.apply_done"
else:
    @dataclass
    class L7EncodedApplication(PlaceholderContentObj): pass
    @dataclass
    class L7Trace(PlaceholderTraceObj): sop_name: str = "lC.SOP.apply_done"


# --- Nested Content Structure ---
if PYDANTIC_AVAILABLE:
    class L6ReflectionPayloadContainer(MadaBaseModel): # Name derived from schema structure
        L6_reflection_payload_obj: L6ReflectionPayloadObj = Field(...)
        L7_encoded_application: L7EncodedApplication = Field(...)

    class L5FieldStateContainer(MadaBaseModel):
        L5_field_state_obj: L5FieldStateObj = Field(...)
        L6_reflection_payload: L6ReflectionPayloadContainer = Field(...) # Corrected nesting

    class L4AnchorStateContainer(MadaBaseModel):
        L4_anchor_state_obj: L4AnchorStateObj = Field(...)
        L5_field_state: L5FieldStateContainer = Field(...) # Corrected nesting

    class L3SurfaceKeymapContainer(MadaBaseModel):
        L3_surface_keymap_obj: L3SurfaceKeymapObj = Field(...)
        L4_anchor_state: L4AnchorStateContainer = Field(...) # Corrected nesting

    class L2FrameTypeContainer(MadaBaseModel):
        L2_frame_type_obj: L2FrameTypeObj = Field(...)
        L3_surface_keymap: L3SurfaceKeymapContainer = Field(...) # Corrected nesting

    class L1StartleReflexContainer(MadaBaseModel): # L1_startle_reflex in schema
        L1_startle_context: L1StartleContext = Field(...) 
        L2_frame_type: L2FrameTypeContainer = Field(...)

    # Raw Signals item
    class RawSignalItem(MadaBaseModel):
        raw_input_id: str
        raw_input_signal: str # Or Any if it can be complex

    class SeedContent(MadaBaseModel):
        raw_signals: List[RawSignalItem] = Field(...)
        L1_startle_reflex: L1StartleReflexContainer = Field(...)

    class TraceMetadata(MadaBaseModel):
        trace_id: str
        L1_trace: L1Trace
        L2_trace: L2Trace = Field(default_factory=L2Trace)
        L3_trace: L3Trace = Field(default_factory=L3Trace)
        L4_trace: L4Trace = Field(default_factory=L4Trace)
        L5_trace: L5Trace = Field(default_factory=L5Trace)
        L6_trace: L6Trace = Field(default_factory=L6Trace)
        L7_trace: L7Trace = Field(default_factory=L7Trace)

    class SeedQAQC(MadaBaseModel):
        version_seed_qa_qc_schema: str = Field("0.1.0", pattern=r"^\d+\.\d+\.\d+$")
        overall_seed_integrity_status: str = "Pending_L7_QA" # Default or enum
        qa_qc_assessment_timestamp: Optional[datetime] = None
        integrity_findings: List[Dict[str, Any]] = Field(default_factory=list) # Simplified
        error_details: Optional[str] = None

    class MadaSeed(MadaBaseModel):
        version: str = Field("0.3.0", pattern=r"^\d+\.\d+\.\d+$")
        seed_id: str
        seed_content: SeedContent
        trace_metadata: TraceMetadata
        seed_QA_QC: SeedQAQC = Field(default_factory=SeedQAQC)
        seed_completion_timestamp: Optional[datetime] = None

        @model_validator(mode='after')
        def ensure_trace_id_matches_seed_id(self) -> 'MadaSeed':
            if self.seed_id and self.trace_metadata and self.trace_metadata.trace_id != self.seed_id:
                # Consider raising a ValueError here or logging a warning if they must match.
                # For now, keeping the pass behavior of the original validator.
                # print(f"Warning: MadaSeed seed_id '{self.seed_id}' does not match trace_metadata.trace_id '{self.trace_metadata.trace_id}'")
                pass # Or raise ValueError("seed_id must match trace_metadata.trace_id")
            return self

else: # Dataclass versions
    @dataclass
    class L6ReflectionPayloadContainer:
        L6_reflection_payload_obj: L6ReflectionPayloadObj
        L7_encoded_application: L7EncodedApplication

    @dataclass
    class L5FieldStateContainer:
        L5_field_state_obj: L5FieldStateObj
        L6_reflection_payload: L6ReflectionPayloadContainer

    @dataclass
    class L4AnchorStateContainer:
        L4_anchor_state_obj: L4AnchorStateObj
        L5_field_state: L5FieldStateContainer

    @dataclass
    class L3SurfaceKeymapContainer:
        L3_surface_keymap_obj: L3SurfaceKeymapObj
        L4_anchor_state: L4AnchorStateContainer

    @dataclass
    class L2FrameTypeContainer:
        L2_frame_type_obj: L2FrameTypeObj
        L3_surface_keymap: L3SurfaceKeymapContainer

    @dataclass
    class L1StartleReflexContainer:
        L1_startle_context: L1StartleContext # Schema name
        L2_frame_type: L2FrameTypeContainer

    @dataclass
    class RawSignalItem:
        raw_input_id: str
        raw_input_signal: str

    @dataclass
    class SeedContent:
        raw_signals: List[RawSignalItem]
        L1_startle_reflex: L1StartleReflexContainer

    @dataclass
    class TraceMetadata:
        trace_id: str
        L1_trace: L1Trace
        L2_trace: L2Trace = dc_field(default_factory=L2Trace)
        L3_trace: L3Trace = dc_field(default_factory=L3Trace)
        L4_trace: L4Trace = dc_field(default_factory=L4Trace)
        L5_trace: L5Trace = dc_field(default_factory=L5Trace)
        L6_trace: L6Trace = dc_field(default_factory=L6Trace)
        L7_trace: L7Trace = dc_field(default_factory=L7Trace)

    @dataclass
    class SeedQAQC:
        version_seed_qa_qc_schema: str = "0.1.0"
        overall_seed_integrity_status: str = "Pending_L7_QA"
        qa_qc_assessment_timestamp: Optional[datetime] = None
        integrity_findings: List[Dict[str, Any]] = dc_field(default_factory=list)
        error_details: Optional[str] = None
        
    @dataclass
    class MadaSeed:
        seed_id: str
        seed_content: SeedContent
        trace_metadata: TraceMetadata
        version: str = "0.3.0"
        seed_QA_QC: SeedQAQC = dc_field(default_factory=SeedQAQC)
        seed_completion_timestamp: Optional[datetime] = None

# Helper for creating UIDs if needed by other modules
def generate_crux_uid(type_hint: str = "generic") -> str:
    return f"urn:crux:uid::{type_hint}::{uuid.uuid4().hex}"

def get_utc_timestamp() -> datetime:
    return datetime.now(timezone.utc)

if __name__ == "__main__":
    if PYDANTIC_AVAILABLE:
        print("Pydantic is available. Testing MadaSeed instantiation.")
        # Example L1 data
        l1_signal_meta = SignalComponentMetadataL1(
            component_role_L1="primary_text_content",
            raw_signal_ref_uid_L1=generate_crux_uid("raw_signal"),
            encoding_status_L1="AssumedUTF8_TextHint",
            media_type_hint_L1="text/plain"
        )
        
        current_time = get_utc_timestamp()
        trace_id = generate_crux_uid("trace")

        l1_context = L1StartleContext(
            L1_epistemic_state_of_startle="Startle_Complete_SignalRefs_Generated",
            trace_creation_time_L1=current_time,
            input_origin_L1="Test_Input_Interface",
            signal_components_metadata_L1=[l1_signal_meta]
        )

        l1_trace_meta = L1Trace(
            completion_timestamp_L1=current_time,
            epistemic_state_L1="Startle_Complete_SignalRefs_Generated",
            L1_trace_creation_time_from_context=current_time,
            L1_input_origin_from_context="Test_Input_Interface",
            L1_signal_component_count=1,
            L1_generated_trace_id=trace_id
        )

        # Create shell for L2-L7 (content and trace) using default_factory for traces
        l2_frame_type_obj = L2FrameTypeObj(version="0.1.2", description="L2 Frame Placeholder") # Example version for L2
        l3_surface_keymap_obj = L3SurfaceKeymapObj(version="0.1.1", description="L3 Keymap Placeholder")
        l4_anchor_state_obj = L4AnchorStateObj(version="0.2.17", description="L4 Anchor Placeholder")
        l5_field_state_obj = L5FieldStateObj(version="0.2.0", description="L5 Field Placeholder")
        l6_reflection_payload_obj = L6ReflectionPayloadObj(version="0.1.6", description="L6 Reflection Placeholder")
        l7_encoded_application_obj = L7EncodedApplication(version="0.1.1", description="L7 Application Placeholder")


        seed_content_data = SeedContent(
            raw_signals=[RawSignalItem(raw_input_id=l1_signal_meta.raw_signal_ref_uid_L1, raw_input_signal="Test input text.")],
            L1_startle_reflex=L1StartleReflexContainer(
                L1_startle_context=l1_context, # Alias L1_startle_context_obj is handled by Pydantic if Field(alias=...) is used
                L2_frame_type=L2FrameTypeContainer(
                    L2_frame_type_obj=l2_frame_type_obj,
                    L3_surface_keymap=L3SurfaceKeymapContainer(
                        L3_surface_keymap_obj=l3_surface_keymap_obj,
                        L4_anchor_state=L4AnchorStateContainer(
                            L4_anchor_state_obj=l4_anchor_state_obj,
                            L5_field_state=L5FieldStateContainer(
                                L5_field_state_obj=l5_field_state_obj,
                                L6_reflection_payload=L6ReflectionPayloadContainer(
                                    L6_reflection_payload_obj=l6_reflection_payload_obj,
                                    L7_encoded_application=l7_encoded_application_obj
                                )
                            )
                        )
                    )
                )
            )
        )

        trace_metadata_data = TraceMetadata(
            trace_id=trace_id,
            L1_trace=l1_trace_meta
            # L2-L7 traces will use default_factory
        )
        
        mada_seed_instance = MadaSeed(
            seed_id=trace_id,
            seed_content=seed_content_data,
            trace_metadata=trace_metadata_data,
            # seed_QA_QC will use default factory
            # seed_completion_timestamp will be None initially
        )
        print("MadaSeed instance created successfully with Pydantic.")
        print(mada_seed_instance.model_dump_json(indent=2))
        
        # Test alias for L1_startle_context
        # This requires L1StartleReflexContainer.L1_startle_context to have alias='L1_startle_context_obj'
        # And also for the model config to have `by_alias=True` for serialization if we want the alias in output
        # For input, Pydantic handles it automatically.
        # Example: L1StartleReflexContainer(L1_startle_context_obj=l1_context, ...)
        # By default, Pydantic serializes using field names, not aliases.
        # To serialize with alias: mada_seed_instance.model_dump_json(indent=2, by_alias=True)

    else:
        print("Pydantic is NOT available. Python dataclasses would be used here.")
        # Create dataclass instances (more verbose setup)
        # Example L1 data
        l1_signal_meta_dc = SignalComponentMetadataL1(
            component_role_L1="primary_text_content",
            raw_signal_ref_uid_L1=generate_crux_uid("raw_signal_dc"),
            encoding_status_L1="AssumedUTF8_TextHint", # No validation as it's just a string
            media_type_hint_L1="text/plain"
        )
        
        current_time_dc = get_utc_timestamp()
        trace_id_dc = generate_crux_uid("trace_dc")

        l1_context_dc = L1StartleContext(
            L1_epistemic_state_of_startle="Startle_Complete_SignalRefs_Generated", # No validation
            trace_creation_time_L1=current_time_dc,
            input_origin_L1="Test_Input_Interface_DC",
            signal_components_metadata_L1=[l1_signal_meta_dc]
        )

        l1_trace_meta_dc = L1Trace(
            completion_timestamp_L1=current_time_dc,
            epistemic_state_L1="Startle_Complete_SignalRefs_Generated", # No validation
            L1_trace_creation_time_from_context=current_time_dc,
            L1_signal_component_count=1,
            L1_generated_trace_id=trace_id_dc
        )
        
        # Shell for L2-L7
        l2_frame_type_obj_dc = L2FrameTypeObj(version="0.1.2", description="L2 Frame Placeholder DC")
        l3_surface_keymap_obj_dc = L3SurfaceKeymapObj(description="L3 Keymap Placeholder DC") # Uses default version
        l4_anchor_state_obj_dc = L4AnchorStateObj(description="L4 Anchor Placeholder DC")
        l5_field_state_obj_dc = L5FieldStateObj(description="L5 Field Placeholder DC")
        l6_reflection_payload_obj_dc = L6ReflectionPayloadObj(description="L6 Reflection Placeholder DC")
        l7_encoded_application_obj_dc = L7EncodedApplication(description="L7 Application Placeholder DC")

        seed_content_data_dc = SeedContent(
            raw_signals=[RawSignalItem(raw_input_id=l1_signal_meta_dc.raw_signal_ref_uid_L1, raw_input_signal="Test input text DC.")],
            L1_startle_reflex=L1StartleReflexContainer(
                L1_startle_context=l1_context_dc,
                L2_frame_type=L2FrameTypeContainer(
                    L2_frame_type_obj=l2_frame_type_obj_dc,
                    L3_surface_keymap=L3SurfaceKeymapContainer(
                        L3_surface_keymap_obj=l3_surface_keymap_obj_dc,
                        L4_anchor_state=L4AnchorStateContainer(
                            L4_anchor_state_obj=l4_anchor_state_obj_dc,
                            L5_field_state=L5FieldStateContainer(
                                L5_field_state_obj=l5_field_state_obj_dc,
                                L6_reflection_payload=L6ReflectionPayloadContainer(
                                    L6_reflection_payload_obj=l6_reflection_payload_obj_dc,
                                    L7_encoded_application=l7_encoded_application_obj_dc
                                )
                            )
                        )
                    )
                )
            )
        )

        trace_metadata_data_dc = TraceMetadata(
            trace_id=trace_id_dc,
            L1_trace=l1_trace_meta_dc
        )
        
        mada_seed_instance_dc = MadaSeed(
            seed_id=trace_id_dc,
            seed_content=seed_content_data_dc,
            trace_metadata=trace_metadata_data_dc
        )
        print("MadaSeed instance created successfully with dataclasses.")
        # Manual JSON serialization would be needed for dataclasses if complex types are involved
        # For this structure, json.dumps should work if datetime is converted to string first
        # import json
        # print(json.dumps(mada_seed_instance_dc, default=str, indent=2))


# Correction for L1StartleReflexContainer if alias is intended for Pydantic:
# In Pydantic, if you want to use 'L1_startle_context_obj' as an alias for 'L1_startle_context'
# during initialization or serialization (model_dump(by_alias=True)), the field should be:
# L1_startle_context: L1StartleContext = Field(..., alias="L1_startle_context_obj")
# However, the schema uses "L1_startle_context" as the key, so the current Pydantic model is correct
# for schema compliance. The SOP's pseudo-code variable name can differ from the schema key.
# The current `L1_startle_context: L1StartleContext = Field(...)` is fine.
# If the schema key was "L1_startle_context_obj", then Field(alias=...) would be useful if our Python
# variable name was `l1_startle_context`.

# Re-checked schema: "L1_startle_context" is the key in `L1_startle_reflex.properties`.
# So, `L1_startle_context: L1StartleContext` is the correct Pydantic field name.
# The SOP pseudo-code variable `L1_startle_context_obj` is just a variable name and doesn't need an alias here.

# For L7_encoded_application, the schema has a property called "version_L7_payload" AND the object itself needs a version.
# The previous task corrected this to have a standard "version" property inside L7_encoded_application.properties.
# My Pydantic model L7EncodedApplication inherits from PlaceholderContentObj which has a "version" field.
# This is consistent with the corrected schema.
